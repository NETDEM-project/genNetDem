#'interaction_generation_simul
#'
#'Generates a series of simultaneously observed groups
#'
#'@param indiv_data indiv_data dataframe containing information on ID, group membership and spatial locations
#'@param pop_mat adjacency matrix for underlying social network structure
#'@param mean_group_size mean group size. Defaults to 2.
#'@param n_ts number of time-steps to simulate grouping events for. Defaults to 20.
#'@param float used in jpc to provide a minimum probability of being sampled in the same group to allow all groups to be filled. Defaults to 0.000000001.
#'@param pm used in jpc to adjust social network connection strengths to probabilities of being sampled in the same group. Defaults to 50.
#'@param pow further adjustment of probabilities of being sampled in the same group based on social network connections. Defaults to 4.
#'
#'@details Generates groups that exist contemporaneously (c.f. interaction_generation_seq), whereby individuals are only present in a single group. Note that the functionality for having close control over the group size distribution is currently limited and could be improved. Group sizes could instead be generated directly from a series of breaks provided if more control is desired.
#'
#'@return A list with two elements: A) the GBI generated by the function; B) a vector indicating which timestep each group occurred in.
#'
#'@export

interaction_generation_simul<-function(indiv_data,pop_mat,
                                       mean_group_size=2,n_ts=20,
                                       float=0.000000001,pm=50,pow=4){

  if(is.data.frame(indiv_data)==FALSE){stop("Correctly formatted indiv_data is required")}
  if(ncol(indiv_data)%in%c(4,5)==FALSE){stop("Correctly formatted indiv_data is required")}
  if(is.matrix(pop_mat)==FALSE){stop("Network must be in adjacency matrix format")}
  if(dim(pop_mat)[1]!=dim(pop_mat)[2]){stop("Adjacency matrix not square")}
  if(n_ts<1){stop("number of timesteps must be 1 or more")}
  if(mean_group_size<0){stop("mean group size must be greater than zero")}
  if(float<0){stop("float must be greater than zero")}
  if(pm<0){stop("pm must be greater than zero")}
  if(float>0.01){warning("Float value is high. Interactions unlikely to be strongly linked to underlying network")}

  grs<-group_calc(nrow(indiv_data),mean_group_size)
  grs<-grs[grs>0]
  gbi2<-matrix(0,nrow=length(grs),ncol=nrow(indiv_data))
  t_data<-indiv_data$indivs
  for(i in 1:length(grs)){
    t_g<-numeric()
    if(length(t_data)>1){
      t_g[1]<-sample(t_data,1,replace=FALSE)
    }
    if(length(t_data)==1){
      t_g[1]<-t_data
    }
    if(grs[i]>1){
      for(j in 2:grs[i]){
        can_join<-t_data[-which(t_data%in%t_g)]
        t_mat<-pop_mat[which(sort(indiv_data$indivs)%in%t_g),which(sort(indiv_data$indivs)%in%can_join)]
        if(is.vector(t_mat)){
          join_probs<-t_mat+float
        } else{
          join_probs<-apply(t_mat,2,jpc,pm=pm,float=float)^pow
        }
        if(length(can_join)>1){
          t_g[j]<-sample(can_join,1,replace=FALSE,prob=join_probs)
        }
        if(length(can_join)==1){
          t_g[j]<-can_join
        }
      }
    }
    gbi2[i,which(sort(indiv_data$indivs)%in%t_g)]<-1
    t_data<-t_data[-which(t_data%in%t_g)]

  }

  samp_wind<-rep(1,nrow(gbi2))

  for(ts in 2:n_ts){
    grs<-group_calc(nrow(indiv_data),mean_group_size)
    grs<-grs[grs>0]
    gbi_t<-matrix(0,nrow=length(grs),ncol=nrow(indiv_data))
    t_data<-indiv_data$indivs
    for(i in 1:length(grs)){
      t_g<-numeric()
      if(length(t_data)>1){
        t_g[1]<-sample(t_data,1,replace=FALSE)
      }
      if(length(t_data)==1){
        t_g[1]<-t_data
      }
      if(grs[i]>1){
        for(j in 2:grs[i]){
          can_join<-t_data[-which(t_data%in%t_g)]
          t_mat<-pop_mat[which(sort(indiv_data$indivs)%in%t_g),which(sort(indiv_data$indivs)%in%can_join)]
          if(is.vector(t_mat)){
            join_probs<-t_mat+float
          } else{
            join_probs<-apply(t_mat,2,jpc,pm=pm,float=float)^pow
          }
          if(length(can_join)>1){
            t_g[j]<-sample(can_join,1,replace=FALSE,prob=join_probs)
          }
          if(length(can_join)==1){
            t_g[j]<-can_join
          }
        }
      }
      gbi_t[i,which(sort(indiv_data$indivs)%in%t_g)]<-1
      t_data<-t_data[-which(t_data%in%t_g)]
    }
    gbi2<-rbind(gbi2,gbi_t)
    samp_wind<-c(samp_wind,rep(ts,nrow(gbi_t)))
  }

  output<-list(gbi2,samp_wind)

  return(output)

}
