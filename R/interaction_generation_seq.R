#'interaction_generation_seq
#'
#'Generates a sequential series of groups
#'
#'@param pop_mat adjacency matrix of underlying social network
#'@param indiv_data indiv_data dataframe including information on IDs, group membership and spatial locations
#'@param ne number of groups
#'@param mgs mean group size
#'@param style_gs group size distribution. Currently either identical (style_gs=”rep”) or Poisson (style_gs=”pois”).
#'@param pm used in jpc to adjust social network connection strengths to probabilities of being sampled in the same group. Defaults to 20
#'@param float used in jpc to provide a minimum probability of being sampled in the same group to allow all groups to be filled. Defaults to 0.0001
#'
#'@details Generates a sequential series of groups (c.f. interaction_generation_simul), whereby each group occurs at a different timestep so can contains overlapping sets of individuals.
#'
#'@return The GBI generated by the function
#'
#'@export

interaction_generation_seq<-function(pop_mat,indiv_data,
                                     ne=1000,mgs=2,style_gs=c("rep","pois"),
                                     pm=20,float=0.00001){

  if(is.data.frame(indiv_data)==FALSE){stop("Correctly formatted indiv_data is required")}
  if(ncol(indiv_data)%in%c(4,5)==FALSE){stop("Correctly formatted indiv_data is required")}
  if(style_gs%in%c("rep","pois")){stop("style_gs must be either 'rep' or 'pois'")}
  if(is.matrix(pop_mat)==FALSE){stop("Network must be in adjacency matrix format")}
  if(dim(pop_mat)[1]!=dim(pop_mat)[2]){stop("Adjacency matrix not square")}
  if(ne<1){stop("number of events must be 1 or more")}
  if(mgs<0){stop("mean group size must be greater than zero")}
  if(float<0){stop("float must be greater than zero")}
  if(pm<0){stop("pm must be greater than zero")}
  if(float>0.01){warning("Float value is high. Interactions unlikely to be strongly linked to underlying network")}

  if(style_gs=="rep"){
    gs<-rep(mgs,ne)
  }
  if(style_gs=="pois"){
    gs<-stats::rpois(ne,5)
  }

  n<-nrow(pop_mat)

  gbi<-matrix(0,nrow=ne,ncol=n)
  for(i in 1:ne){
    t_g<-numeric()
    t_g[1]<-sample(indiv_data$indivs,1,replace=FALSE)
    for(j in 2:gs[i]){
      can_join<-indiv_data$indivs[-which(indiv_data$indivs%in%t_g)]
      t_mat<-pop_mat[t_g,can_join]
      if(is.vector(t_mat)){
        join_probs<-t_mat+float
      } else{
        join_probs<-apply(t_mat,2,jpc,pm=pm,float=float)
      }
      if(length(can_join)>1){
        t_g[j]<-sample(can_join,1,replace=FALSE,prob=join_probs)
      }
      if(length(can_join)==1){
        t_g[j]<-can_join
      }
    }
    gbi[i,t_g]<-1
  }

  return(gbi)

}

